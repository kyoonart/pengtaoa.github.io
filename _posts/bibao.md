---
title: 关于闭包的一些问题
date: 2020-04-26 16:18:27
tags: JavaScript
---

# 闭包

## 怎么产生闭包

当一个嵌套的内部（子）函数引用了嵌套的外部（父）函数的变量（函数）时，就产生了闭包。其实关于很多闭包的定义我感觉都不怎么准确的，最后终于看了一本书是《你不知道的js》这个定义让我比较信服：

** **闭包：当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行。** **

<!-- more -->

## 闭包到底是什么

- 闭包是嵌套的内部（子）函数
- 包含在被引用变量（函数）的对象
  注意：闭包存在于嵌套的内部（子）函数中

## 产生闭包的条件

- 函数嵌套
- 内部函数引用了外部函数的变量（函数）

## 哪些是闭包？

~~~js
 function foo() {
    var a = 2;
    function bar() {
        console.log( a ); // 2
    }
    bar();
}
foo();
~~~

基于词法作用域的查找规则，函数bar() 可以访问外部作用域中的变量a（这个例子中的是一个RHS 引用查询）。

那么这个是闭包吗？**很遗憾不是，因为bar函数执行在其定义的词法作用域处。**

不过稍加修改后就是闭包了

~~~js
 function foo() {
    var a = 2;
    function bar() {
        console.log( a ); // 2
    }
    return bar
}
let baz=foo();
baz()
~~~

baz函数执行实际上只是通过不同的标识符引用调用了内部的函数bar()

bar()函数显然可以被正常执行，也就是**在自己定义的词法作用域以外的地方执行**。

根据作用域的规则，函数bar()函数能够访问foo()的内部作用域，因此foo()执行完后，其内部作用域并不会被回收，bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。

这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。

当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包

~~~js
function foo() {
    var a = 2;
    function baz() {
        console.log( a ); // 2
    }
    bar( baz );
}
function bar(fn) {
    fn(); // 妈妈快看呀，这就是闭包！
}
~~~

是的，这也是个闭包，**这里将baz传递出去了在bar()函数中执行，而不是在自己定义的词法作用域中执行，但是它却保留这对定义时词法作用域的引用**

在看一个例子

~~~js
var fn;
function foo() {
    var a = 2;
    function baz() {
        console.log( a );
    }
    fn = baz; // 将baz 分配给全局变量
}
function bar() {
    fn(); // 妈妈快看呀，这就是闭包！
}
foo();
bar(); // 2
~~~

是的没错，这还是个闭包，**无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。**

在看经典面试题目

~~~js
for (var i=1; i<=5; i++) {
　　setTimeout( function timer() {
　　　　console.log( i );
　　}, i*1000 );
}
~~~

大家都知道这段代码会输出五次6，为什么呢？

**因为setTimeOut()是异步函数，也就是等循环结束后才去执行setTimeOut()中的回调函数，而在for循环中，并不存在着块级作用域，也就是这个i声明在全局作用域中，并且自始至终只有一个i(因为var声明会变量声明提升，也就是其实只声明了一次)，而在for循环结束后，这个i的值是6。setTimeOut()中的回调函数timer()保持着对i的引用，但是5次timer()函数引用的只是同一个i，所以输出5次6。**

改进的方法太多了 这里就暂时3种吧

~~~js'
// 它需要有自己的变量，用来在每个迭代中储存i 的值：
for (var i=1; i<=5; i++) {
    (function() {
        var j = i;
        setTimeout( function timer() {
            console.log( j );
        }, j*1000 );
    })();
}
// 行了！它能正常工作了！。
// 可以对这段代码进行一些改进：
for (var i=1; i<=5; i++) {
    (function(j) {
        setTimeout( function timer() {
            console.log( j );
        }, j*1000 );
    })( i );
}
//当然你也可以这样写
for (var i=1; i<=5; i++) {
    (function(i) {
        setTimeout( function timer() {
            console.log( i );
        }, i*1000 );
    })( i );
}
~~~

